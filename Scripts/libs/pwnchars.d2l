// !!!!!!!!!!!!!!!!!!!!!!!!!!!!DO NOT EDIT THIS FILE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

/* ææææææææææææææææææææææææææææ
System Variables
ææææææææææææææææææææææææææææ */

var BowAmount=45;
var JavAmount=31;
var attackzombies=false;
var zombieSkill="temp";
var zombieStand=false;
var BowFirst=false;
var RangedAtt=false;
var maxattacks=30;

var usemerc=true;
var merccost=50000;

var ShopIton=true;
var AlwaysMalah=false;
var AlwaysLarzuk=false;
var MalahNotLarzuk=false;
var GoToAnya=false;

var repairpercent=25;
var taunts=true;
var FreeSpace=3;
var charsnag="snagit.ini";
var skipheallife=75;
var skiphealmana=35;
var walkdel=40;

var immunities=new Array(7);
var immunecombos=new Array();
var enchantments = new Array(13);
var enchantcombos=new Array();
var auras = new Array(8);
var enchantauracombos=new Array();
if(me.classid==6)
{
	print("Assasins are not currently supported.  Sorry for the inconvenience");
	stop();
}
if(me.classid==5)
{
	var DruidShift="Wearwolf";
	var DruidSummon="Summon Grizzly";
	var SummonNumber=0;
	var CastonPindle=true;
	var Barbs=false;
	var Heart=false;
	var OakSage=true;
	var DruidSkill="Fury";
	druidvariables();
}
if(me.classid==4)
{
	var shout=false;
	var BCommand=false;
	var Border=true;
	var FindItem=true;
	var ChangeWeaponPre=false;
	var ChangeWeaponHork=false;
	var UseBerserk=true;
	var wwdistance=5;
	Barbvariables();
}
if(me.classid==3)
{
	var FlashTimer=0;
	var StartFOH=false;
	var FOHAura="Conviction";
	var PallyAttack="Zeal";
	var AuraA="Holy Freeze";
	var AuraB="Fanaticism";
	var AuraC=false;
	var SwitchPhys=false;
	var SwitchAuraA=false;
	var SwitchAuraB=false;
	var SwitchAuraC=false;
	var SwitchAmount=50;
	var UseVigor=true;
	var HolyShield=true;
	var ZAuraA="Holy Freeze";
	var ZAuraB="Fanaticism";
	var ZAuraC=false;
	paladinvariables();
}
if(me.classid==2)
{
	var CorpsePopping=false;
	var BodySkill="Corpse Explosion";
	var NecroSkill="Bone Spirit";
	var BoneBehind=true;
	var BonePindle=true;
	var BoneNumber=1;
	var BoneArmor=true;
	var NecroCurse="Lower Resist";
	var NecroSummon="FireGolem";
	var SummonBefore=false;
	var CastonPindle=true;
	necrovariables();
}
if(me.classid==1)
{
	var spelllist=new Array();
	var prelist=new Array();
	var timedfirst=false;
	var statictimes=1;
	var untimedrepeat=2;
	var teledistance=10;
	var SwitchOnKill=true;
	var SwitchHP=40;
	var StallKill=false;
	var StallHP=40;
	var MercSkipPhys=true;
	var enchantmerc=false;
	var zombieusestatic=true;
	var zombiestatictimes=2;
	var numtimed = 0;
	var numuntimed = 0;
	var currenttimed = 1;
	var currentuntimed = 1;
	Sorcvariables();
	var numspells=spelllist.length;
	var timedspell = new Array();
	var untimedspell = new Array();
}
if(me.classid==0)
{
	var PrecastValk=true;
	var CastValkOn=false;
	var CastDecoyOn=true;
	var BowFirst=true;
	var JavFirst=false;
	var SwitchPhys=false;
	var PhysAmount=50;
	var SwitchLit=false;
	var LitAmount=50;
	var StartIt=0;
	var PickupShield=false;
	var BowAttack=new Array();
	var JavAttack=new Array();
	var BowNumber=new Array();
	var JavNumber=new Array();
	amazonvariables();
}


/* ææææææææææææææææææææææææææææ
Character precasts pre portal
ææææææææææææææææææææææææææææ */

function characterpreportal()
{
	switch(me.classid)
	{
		case 5: druidpre(); break;
		case 4: barbpre(); break;
		case 3: palpre(); break;
		case 2: necpre(); break;
		case 1: sorcpre(); break;
		case 0: zonpre(); break;
	}
}

function characterpostportal()
{
	switch(me.classid)
	{
		case 5: druidpost(); return;
		case 4: barbpost(); return;
		case 2: necpost(); return;
		case 1: sorcpost(); return;
	}
}

function attackpindle()
{
	if(me.classid==1) teleporttopindle();
	else walktopindle();

	checkfortarget(pindle);
	checkimmunities(pindle);

	switch(me.classid)
	{
		case 5: druidatt(); break;
		case 4: barbatt(); break;
		case 3: palatt(); break;
		case 2: necatt(); break;
		case 1: sorcatt(); break;
		case 0: zonatt(); break;
	}

	print("ÿc0" + target.name + " killed!");
	if (taunts) print("ÿc4Pindleskinÿc@: AAAAaaaaaarrrgghh...!!!");
	me.overhead("pwnd!!!");

	target=false;
	pickiton();
}

/* ææææææææææææææææææææææææææææ
Druid Functions
ææææææææææææææææææææææææææææ */

function druidpre()
{
	if(SummonNumber >= 1)
	{
		if(CastonPindle)
			SummonNumber -= 1;
		for (s = 0; s < SummonNumber; s++)
		{
			DoCast(DruidSummon,0);
		}
	}

	if (Barbs)
		DoCast("Spirit of Barbs",0);
	if (Heart)
		DoCast("Heart of Wolverine",0);
	if (OakSage)
		DoCast("Oak Sage",0);

	DoCast(DruidShift,0);
}

function druidpost()
{
	if(!me.getState(139) && !me.getState(140))
		DoCast(DruidShift,0);
}

function druidatt()
{
	if(CastonPindle)
	{
		DoCast(DruidSummon,0,target);
	}
	while (target.hp > 0)
	{
		characterpostportal();

		DoCast(DruidSkill,0,target);
		checkattacks();
	}
}

/* ææææææææææææææææææææææææææææ
Necro Functions
ææææææææææææææææææææææææææææ */

function necpre()
{
	if(SummonBefore)
		DoCast(NecroSummon,0);

	if (BoneArmor)
		DoCast("Bone Armor",0);
}

function necpost()
{
	if(!me.getState(14) && BoneArmor)
		DoCast("Bone Armor",0);
}

function necatt()
{
	if(CastonPindle)
		DoCast(NecroSummon,0,target);

	if(BonePindle)
	{
		for (q = 1; q <= BoneNumber; q++)
			DoCast("Bone Prison",0,target);
	}

	DoCast(NecroCurse,0,target);

	if(BoneBehind)
		DoCast("Bone Wall",0,10058,13242);

	if(CorpsePopping) NecroPopAttack();
	while (target.hp > 0)
	{
		DoCast(NecroSkill,0,target);
		checkattacks();
		characterpostportal();
	}
}

function NecroPopAttack()
{
	npc = getUnit(1);
	if (npc) do {
		owner = npc.getParent();
		if(npc.name != "Dummy" && npc.name != "an evil force"
		&& npc.name != mercname && npc.name != target.name
		&& npc.y <= me.y && !owner)
		{
			print("Attacking a " +npc.name);
			while(npc.hp > 0)
			{
				DoCast(NecroSkill,0,npc);
			}
			print("Popping the " +npc.name +"'s corpse!");
			DoCast(BodySkill,0,npc);
		}
	} while (npc.getNext());
}

/* ææææææææææææææææææææææææææææ
Pally Functions
ææææææææææææææææææææææææææææ */

function palpre()
{
	if (HolyShield)
		DoCast("Holy Shield",0);
	if(UseVigor) me.setSkill("Vigor", 0);
}

function palatt()
{
	print("Pally script as completed by Darien!");
	if(StartFOH)
	{
		me.setSkill(FOHAura, 0);
		for (s = 0; s < StartFOH; s++)
			DoCast("Fist of the Heavens",1,target);
	}
	walkto(target.x,target.y);
	if(target.getStat(36) > SwitchAmount)
	{
		if(SwitchPhys) PallyAttack=SwitchPhys;
		if(SwitchAuraA || SwitchAuraB || SwitchAuraC)
		{
			AuraA=SwitchAuraA;
			AuraB=SwitchAuraB;
			AuraC=SwitchAuraC;
		}
	}
	if(AuraA) me.setSkill(AuraA, 0);
	FlashTimer=new Date().getTime();

	while (target.hp > 0)
	{
		DoCast(PallyAttack,1,target);
		checkattacks();
		AuraFlash();
	}
}

function AuraFlash()
{
	if(new Date().getTime()-FlashTimer >= 8000)
	{
		if(AuraA) me.setSkill(AuraA, 0);
		FlashTimer=new Date().getTime();
	}
	else if(new Date().getTime()-FlashTimer >= 6000 && AuraC) me.setSkill(AuraC, 0);
	else if(new Date().getTime()-FlashTimer >= 3000 && AuraB) me.setSkill(AuraB, 0);
}

/* ææææææææææææææææææææææææææææ
Zon Functions
ææææææææææææææææææææææææææææ */

function zonpre()
{
	if (PrecastValk)
		DoCast("Valkyrie",0);

	if (JavFirst)
	{
		check = getUnit(4);
		if (check) do
		{
			if(check.itemloc == 11 || check.itemloc == 12)
			{
				if((check.itemtype == 87 || check.itemtype == 44 || check.itemtype == 43 || check.itemtype == 42) && item.getFlag(0x400000) == 0)
				{
					print("Switching to javelins!");
					doWeaponSwitch();
					break;
				}
			}
		} while (check.getNext());
	}
}

function zonatt()
{
	print("Zon script as completed by Swedish Power!");

	if((target.getStat(36) > PhysAmount && SwitchPhys) || (target.getStat(41) > LitAmount && SwitchLit))
	{
		doWeaponSwitch();
		StartIt=0;
	}

	if (CastValkOn)
		DoCast("Valkyrie",0,target);

	if (CastDecoyOn)
		DoCast("Dopplezon",0,target);

	while (target.hp > 0)
	{
		check = getUnit(4);
		if (check) do
		{
			if((check.itemloc == 4 || check.itemloc == 5) && check.mode == 1)
			{
				//Jav attacks
				if(check.itemtype == 87 || check.itemtype == 44 || check.itemtype == 43 || check.itemtype == 42)
				{
					for (x = 0; x < JavAttack.length; x++)
					{
						for (r = 1; r <= JavNumber[x]; r++)
							DoCast(JavAttack[x],0,target);
					}
					checkattacks();
				}
				//Bow attacks
				if(check.itemtype == 85 || check.itemtype == 27 || check.itemtype == 35)
				{
					for (y = 0; y < BowAttack.length; y++)
					{
						for (x = 1; x <= BowNumber[y]; x++)
							DoCast(BowAttack[y],0,target);
					}
					checkattacks();
				}
			}
		} while (check.getNext());

		if (attackscompleted == StartIt && StartIt > 0)
		{
			print("Switch attacks!");
			doWeaponSwitch();
		}
	}

	if(PickupShield)
	{
		check = getUnit(4);
		if (check) do
		{
			if((check.itemloc == 4 || check.itemloc == 5) && check.mode==1)
			{
				if(check.itemtype == 2)
				{
					PickupShield=false;
					break;
				}
			}
		} while (check.getNext());
	}
	if(PickupShield)
	{
		print("Switching to your shield!");
		doWeaponSwitch();
	}
}


/* ææææææææææææææææææææææææææææ
Barb Functions
ææææææææææææææææææææææææææææ */

function barbpre()
{
	if(ChangeWeaponPre || ChangeWeaponHork)
		doWeaponSwitch(0);
}

function barbpost()
{
	if(ChangeWeaponPre)
		doWeaponSwitch(1);
	if(BCommand)
		DoCast("Battle Command",0);
	if(shout)
		DoCast("Shout",0);
	if(Border)
		DoCast("Battle Orders",0);
	if(ChangeWeaponPre)
		doWeaponSwitch(0);
}

function barbatt()
{
	while (target.hp > 0)
	{
		if(target.getStat(36) > 99 && UseBerserk) WWandBerz();
		else WWAtt(target);
	}
	DoCast();
	if (FindItem)
		UseFindItem();
}

function WWAtt(enemy)
{
	while(enemy.hp > 0)
	{
		DoCast("Whirlwind",0,enemy.x,enemy.y + wwdistance);
		if(enemy.hp <= 0) break;

		DoCast("Whirlwind",0,enemy.x,enemy.y - wwdistance);
	}
}

function WWandBerz()
{
	var monster;
	while(monster = GetClosestMonster(me.x,me.y,20)) WWAtt(monster);

	walkto(target.x,target.y);
	for (s = 0; s < 6; s++)
	{
		DoCast("Berserk",0,target);
		if(target.hp <= 0) return;
	}
}

function UseFindItem()
{
	DoDel(500);
	print("ÿc8Using Find Item skill on Pindle");
	if(ChangeWeaponHork)
		doWeaponSwitch(1);
	DoCast("Find Item",0,target);
	if(ChangeWeaponHork)
		doWeaponSwitch(0);
}

/* ææææææææææææææææææææææææææææ
Sorc Functions
ææææææææææææææææææææææææææææ */

function sorcpre()
{
	sorcsetskills();
	if(SwitchOnKill) mfswitch("attack");

	for (t = 0; t < prelist.length; t++)
	{
		if (prelist[t] != "Thunder Storm")
			DoCast(prelist[t],0);
	}
}

function sorcpost()
{
	for (t = 0; t < prelist.length; t++)
	{
		if (prelist[t] == "Thunder Storm")
			DoCast(prelist[t],0);
	}
	if (enchantmerc)
	{
		merc = getUnit(1,mercname);
		if (merc)
			DoCast("Enchant",0,merc);
	}
}

function sorcatt()
{
	if (statictimes > 0)
		sorccaststatic();

	while (target.hp > 0)
	{
		if (numtimed >= 1)
		{
			dprint("Casting " + timedspell[currenttimed]);
			DoCast(timedspell[currenttimed],0,target.x,target.y);
			if(SorcCheckutil()) return;

			currenttimed++;
			if (currenttimed > numtimed) currenttimed = 1;

			if (numuntimed >= 1)
			{
				TimeDel : while (me.getState(121))
				{
					for (r = 1; r <= untimedrepeat; r++)
					{
						dprint("Casting " + untimedspell[currentuntimed]);
						if(!DoCast(untimedspell[currentuntimed],0,target.x,target.y)) break TimeDel;
						if(SorcCheckutil()) return;
					}
				}
				currentuntimed++;
				if (currentuntimed > numuntimed) currentuntimed = 1;
			}
			else
			{
				while (me.getState(121))
				{
					if (target.hp <= 0) return;
					DoDel(10);
				}
			}
		}
		else
		{
			for (n = 1; n <= numuntimed; n++)
			{
				for (r = 1; r <= untimedrepeat; r++)
				{
					dprint("Casting " + untimedspell[n]);
					DoCast(untimedspell[n],0,target.x,target.y);
					if(SorcCheckutil()) return;
				}
			}
		}
		checkattacks();
	}
}

function SorcCheckutil()
{
	if (target.hp <= 0) return true;
	if(SwitchOnKill && target.hp <= SwitchHP) mfswitch("find");
	merc = getUnit(1,mercname);
	if(merc && StallKill && target.hp <= StallHP && !(target.getStat(36) > 99 && MercSkipPhys))
	{
		StallKill=false;
		print("Stalling for your merc to kill pindleskin");
		for (ty = 0; ty < 100; ty++)
		{
			DoDel(20);
			checkposition(10063, 13234 - teledistance);
			if(target.hp <= 0) return true;
		}
	}
	checkposition(10063, 13234 - teledistance);
}

function DropABomb()
{
	if (usemerc) merc=getUnit(1,mercname);
	if (usemerc && merc && merc.hp > 0)
		DoCast(timedspell[currenttimed],0,merc.x,merc.y);
	else
		DoCast(timedspell[currenttimed],0,me.x,me.y);
}

function sorccaststatic()
{
	if (statictimes > 0 && statictimes < 1) statictimes = 1;

	if ((timedfirst) && (numtimed > 0))
	{
		dprint("Casting " + timedspell[currenttimed]);

		if(timedspell[currenttimed]=="Meteor") DropABomb();
		else DoCast(timedspell[currenttimed],0,target.x,target.y);

		currenttimed++;
		if (currenttimed > numtimed) currenttimed = 1;

		if(SorcCheckutil()) return;

		for (n = 1; n <= statictimes; n++)
		{
			dprint("Casting Static Field #" + n);
			DoCast("Static Field",0,target);

			if(SorcCheckutil()) return;
		}
		while (me.getState(121)) DoDel(10);
	}
	else
	{
		for (n = 1; n <= statictimes; n++)
		{
			dprint("Casting Static Field #" + n);
			DoCast("Static Field",0,target);

			if(SorcCheckutil()) return;
		}
	}
}

function teleporttopindle()
{
	if(!nooverheads) me.overhead("Teleporting to Pindleskin");
	MoveTo(10063, 13280);
	MoveTo(10061, 13256);
	MoveTo(10063, 13234 - teledistance);
}

function mfswitch(which)
{
	var mainmf=0;
	var switchmf=0;
	switchavailable=false;
	check = getUnit(4);
	if (check) do
	{
		owner = check.getParent();
		if(owner) if(owner.name==me.name)
		{
			if((check.itemloc == 4 || check.itemloc == 5) && check.mode == 1)
			{
				mainmf+=check.getStat(80);
				if(check.getStat(240) != 0) mainmf+=parseInt(me.getStat(12) * (check.getStat(240) / 8));
			}

			if((check.itemloc == 11 || check.itemloc == 12) && check.mode == 1)
			{
				switchavailable=true;
				switchmf+=check.getStat(80);
				if(check.getStat(240) != 0) switchmf+=parseInt(me.getStat(12) * (check.getStat(240) / 8));
			}
		}
	} while (check.getNext());

	if(switchavailable)
	{
		dprint("Your main magic find is: (" +mainmf +")   Your weapon switch has: (" +switchmf +") magic find");
		if(mainmf>switchmf && which=="attack")
			doWeaponSwitch();
		if(mainmf<switchmf && which=="find")
			doWeaponSwitch();
	}
}

function sorcsetskills()
{
	if (numspells <= 0) stopmessage("Number of spells set to 0!!!");

	for (s = 0; s < numspells; s++)
	{
		var istimed = sorcchecktiming(spelllist[s]);
		if (istimed)
		{
			numtimed++;
			timedspell[numtimed] = spelllist[s];
		}
		else
		{
			numuntimed++;
			untimedspell[numuntimed] = spelllist[s];
		}
	}

	for (t = 1; t <= numtimed; t++)
		dprint("Timed spell #" + t + " is: " + timedspell[t] + ", Skill level: " + me.getSkill((timedspell[t]),0));

	for (u = 1; u <= numuntimed; u++)
		dprint("Untimed spell #" + u + " is: " + untimedspell[u] + ", Skill level: " + me.getSkill((untimedspell[u]),0));
}

function sorcchecktiming(spellname)
{
	switch(spellname)
	{
		case "Frozen Orb":
		case "Blizzard":
		case "Fire Wall":
		case "Meteor":
		case "Hydra": return true;
		default: return false;
	}
}

/* ææææææææææææææææææææææææææææ
Zombie attacking
ææææææææææææææææææææææææææææ */

// - reworked zombie routine.  now use any char/any skill :)
function zombieattack()
{
	if(me.classid==3)
	{
		AuraA=ZAuraA;
		AuraB=ZAuraB;
		AuraC=ZAuraC;
		if(AuraA) me.setSkill(AuraA, 0);
		FlashTimer=new Date().getTime();
	}
	killall(me.x,me.y,null,10);
	if (me.classid != 1)
	{
		killall(10056,13234,null,5);
		killall(10057,13242,null,5);
		killall(10058,13250,null,5);
	} else MoveTo(10063, 13234);
	killall(10061,13263,null,15);
	print("Prowling Dead were pwned!! kekekeke");
}

function killall(x, y, monType, range)
{
	MoveTo(x, y);
	if (x == 10061 && y == 13263)
		while(!GetClosestMonster(me.x,me.y,range,monType)) DoDel(50);

	killloop: while(monster = GetClosestMonster(me.x,me.y,range,monType))
	{
		if (!zombieStand && zombieSkill != "Whirlwind")
			MoveTo(monster.x,monster.y);
		if (me.classid == 1 && zombieusestatic)
		{
			for (s = 1; s <= zombiestatictimes; s++)
			{
				dprint("Casting Static Field #" + s);
				DoCast("Static Field",0,monster);
				if (monster.hp <= 0) break;
			}
		}
		while (monster.hp > 0)
		{
			if (zombieSkill == "Whirlwind") WWAtt(monster);
			else {
				if (zombieStand)
					checkposition(x, y);
				else
					checkposition(monster.x, monster.y);

				if(me.classid!=3)
				{
					if(!DoCast(zombieSkill,0,monster)) return false;
				}
				else
				{
					AuraFlash();
					if(!DoCast(zombieSkill,1,monster)) return false;
				}
			}

			while (me.getState(121)) DoDel(20);
		}
	}
	pickiton();
}

function GetClosestMonster(x, y, r, n) {
	// replaced with logic from scavenger's bloodybarb.d2j
	if (arguments.length < 4) n = null;

	closest_dist = r;
	monster_id = 0;
	mon = getUnit(1,n);
	if (mon) do {
		// - allow searching for specific monster type
		if (mon && mon.hp > 0 && mon.mode != 0 && mon.mode != 12 && mon.name != "Pindleskin" && mon.name != "Hydra") {
			p = mon.getParent();
			if (!p || p.name != me.name) {
				dist = Dist(mon.x, mon.y, x, y);
				if (dist <= closest_dist) {
					closest_dist = dist;
					monster_id = mon.id
				}
			}
		}
	}while(mon && mon.getNext(n));

	// - skip this if no monsters found
	if (monster_id)
	{
		mon = getUnit(1);
		if (mon) do {
			if (mon && mon.hp > 0 && mon.mode != 0 && mon.mode != 12 && mon.name != "Pindleskin" && mon.name != "Hydra") {
				p = mon.getParent();
				if (!p || p.name != me.name) {
					if (mon.id == monster_id) {
						return mon;
					}
				}
			}
		}while(mon && mon.getNext());
		print("Close enemy not on 2nd detect");
	}

	return false;
}

function Dist(x1, y1, x2, y2) {
	return Math.floor(Math.sqrt(Dist2(x1, y1, x2, y2))); }

function Dist2(x1, y1, x2, y2) {
	return Math.floor((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }